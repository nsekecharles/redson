package com.sidemash.redson.util;


public interface ImmutableVector<T> {

    T get(int index);
/*
    T getHead();

    T getLast();

    boolean contains(Object elem);

    <U> U foldLeft(U seed, BiFunction<U, T, U> op);

    <U> U foldRight(U seed, BiFunction<T, U, U> op);

    boolean isDefinedAt(int index);

    boolean exists(Predicate<? super T> predicate);

    ImmutableVector<T>  filterNot(Predicate<? super T> predicate);

    ImmutableVector<T>  filter(Predicate<? super T> predicate);

    ImmutableVector<T> distinct();

    T getTail();

    ImmutableVector<T> drop(int nb);

    ImmutableVector<T> dropRight(int nb);

    ImmutableVector<T> takeRight(int nb);

    ImmutableVector<T> dropWhile(Predicate<? super T> predicate);

    ImmutableVector<T> takeWhile(Predicate<? super T> predicate);

    ImmutableVector<T> count(Predicate<? super T> predicate);

    ImmutableVector<T> take(int nb);

    ImmutableVector<T> updated(int index, T elem);

    ImmutableVector<T> updated(int index, UnaryOperator<? super T> elem);

    ImmutableVector<T> updated(Predicate<Integer> predicate, UnaryOperator<? super T> elem);

    ImmutableVector<T> sortWith(Comparator<? super T> comparator);

    ImmutableVector<T> maxWith(Comparator<? super T> comparator);

    ImmutableVector<T> minWith(Comparator<? super T> comparator);

    Iterator<T> iterator();

    ImmutableVector<T> reverse();

    <R> ImmutableVector<R> map(Function<? super T, ? extends R> mapper);

    Stream<T> stream();
    */
}
